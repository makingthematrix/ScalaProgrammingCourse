# Praca w Zespole

### Wymagania 
Ten wykład jest blisko związany z wykładem "Git i GitHub". Najlepiej byłoby go zrobić zaraz na następnych zajęciach.

### Opis
W tym wykładzie omówimy metodyki rozwoju oprogramowania, porównując tradycyjne i zwinne podejścia. Przedstawimy kluczowe fazy procesu budowy oprogramowania: zbieranie wymagań, planowanie, implementację, testowanie, weryfikację i wdrożenie.

Następnie porozmawiamy o Manifeście Agile i jego podstawowych wartościach. Przedstawimy główne implementacje i kluczowe postaci za nimi stojące. Skupimy się na Scrumie (Ken Schwaber i Jeff Sutherland) oraz Kanbanie (Ōno Taiichi), ale wspomnimy również o Kent Becku, Martinie Fowlerze i Robercie C. Martinie. Szczegółowo porównamy fazy Scrum i Waterfall. Później zbadamy cykl życia zadania, obejmujący źródła zadań, etapy zarządzania zadaniami, oraz narzędzia takie jak JIRA i GitHub Project.

Później zajmiemy się różnicą między teorią a praktyką. Omówimy produktywność zespołu, dystrybucję zadań i unikanie problemów takich jak wypalenie zawodowe.


### Plan wykładu
* Fazy budowy oprogramowania:
  * Zbieranie wymagań
  * Planowanie
  * Implementacja
  * Testowanie
  * Weryfikacja
  * Uruchomienie (+ feedback)
    * Test in production (czasem to ma sens)
* Waterfall model
  * Lepszy waterfall z feedbackiem na każdym etapie
* Agile Manifesto
  * Individuals and interactions over processes and tools
  * Working software over comprehensive documentation
  * Customer collaboration over contract negotiation
  * Responding to change over following the plan
* Główni teoretycy i ich pomysły (głównie Scrum i Kanban, ale wspomnieć też o innych)
  * Ken Schwaber, Jeff Sutherland - Scrum 
  * Ōno Taiichi - Kanban
  * Ken Beck - Extreme Programming (pair programming, mob programming)
  * Martin Fowler - code patterns, refactoring
  * Robert C. Martin - SOLID principles
* Fazy Scruma (w porównaniu z waterfall)
  * Zbieranie wymagań
  * Planowanie sprintu
  * Sprint, standupy
  * Minimum Viable Product
  * Post mortem, retrospektywa
* Proces życia zadania
  * Żródła zadań
    * bugi od użytkowników
    * bugi wewnętrzne (testy, dog fooding)
    * nowe feature'y od użytkowników
    * nowe feature'y od menadżerów
  * To Do, In Progress, Done
  * Won't Fix (Shelved, Postponed, Functions as Designed)
  * Review
  * Backlog
  * Priority vs severity
* Narzędzia:
  * JIRA, YouTrack
  * GitHub Project, Trello
  * Zwykła korkowa tablica z karteczkami
  * GitHub PRs + Code Review
* Teoria a praktyka
  * Brak dokładnie zdefiniowanych ról
  * Różne zespoły używają różnych metodologii (innych Agile, ale też nie-Agile)
  * Team leader: menadżer, tech expert, wszystko pomiędzy
  * Scrum master: nie powinien być team leaderem, ale często jest
  * Dziwny przypadek QA engineer - powinien być w zespole, ale nie jest
  * Bus factor vs efektywność wynikająca ze specjalizacji vs context switching
  * Rytualizacja standupów, post mortem i retrospektyw
  * Głęboki backlog, zadania-zombie, strzały z boku, zadania-bloby, zadania-wyjątki
  * Wstępny plan często jest robiony na podstawie błędnych założeń,
* Mit super-programisty
  * Sytuacja na rynku pracy (oferty pracy głównie dla senior developerów)
  * Estymacja produktywności zespołu
  * Bus factor, wąskie gardło
  * Gate-keeping, the impostor syndrom, wypalenie zawodowe
  * Alternatywa: balans w podziale obowiązków z uwgzlędnieniem osobistych preferencji

